"""
Library Name: Custom Mqtt
Authors: Dishant
Use case: This library is custom made for iot software. Users can
    create a persistent mqtt client.
Description:
    Users can easily instantiate a custom mqtt object using minimum number
    of parameters. The range of parameters accepted in the form of a
    json makes the mqtt client object configurable.
    The main caveat is that the custom mqtt client object is
    persistent. It makes sense to create such a client by services which
    always require a mqtt connection.
"""

import paho.mqtt.publish as publish_single
import paho.mqtt.client as mqtt
import ssl
import time
from retry import retry
import threading
from queue import Queue
import json
import logging
from unittest.mock import Mock
import logging


class MqttCustom:
    """
    The main interface and entry point for instantiating the custom
    mqtt client object.

    Attributes:
        client (:obj: Mqtt.Client): Standard/Raw mqtt client
            instance. This is only active when the connection is started
            by calling start.
        clientId (str): Unique client id string used when connecting to the
            broker. If not passed in credentials, it will be randomly
            generated by standard mqtt library.
        server (str): The hostname or IP address of the broker. If not
            passed in credentials, it will be set as localhost.
        port (int): Network port of the server host to connect to. Defaults
            to 1883.
        maxMqttReconnectDelay (int): The client will automatically retry
            connection. Between each attempt it will wait a number of
            seconds between 1 and maxMqttReconnectDelay
            seconds. Defaults to 256 seconds.
        willSetTopic (str): Topic that the will message will be
            published to. Defaults to None.
        willSetPayload (str): the message to send as a
            will. Defaults to None.
        keepalive (int): maximum period in seconds allowed between
            communications with the broker. Defaults to 60 seconds.
        certs (dict): certs and info required to connect to aws iot
            broker. All file paths mentioned are string. Iot protocol
            name is used to configure ssl alpn required to connect to aws iot.
            Example:
                {
                    "iotProtocolName": "x-amzn-mqtt-ca",
                    "ca": "<ca file path>",
                    "cert": "<cert file path>",
                    "key": "<key file path>"
                }
        queueSize (int): Items from queue will be published when
            the size reaches this limit. size is in terms of number of items.
            Default : 5
        batchSize (int): Items from batch will be published when
            the size reaches this limit. size is in terms of number of items.
            Default : 5
        publishInterval (int): Time in seconds after which items
            from batch and queue will be published.
            Default : 60
        started(bool): Indicates whether mqtt client connection has been
            initiated or not
    """

    def __init__(
        self,
        on_connect=Mock(),
        on_message=Mock(),
        on_disconnect=Mock(),
        credentials=None,
        userdata=None,
        log_level=logging.INFO,
    ):
        """
        Sets up the parameters required to setup the mqtt client. It
        does not creates the mqtt client just yet, the user
        needs to call start to create the client and initiate
        the mqtt connection.
        Args:
            on_connect_func_ref (func_ref): Called when the client gets connected
                to broker. The function has to be of the signature -->
                `def on_connect(client, userdata, flags, rc)`
            on_message_func_ref (func_ref): Called when a message has been received
                on a topic that the client subscribes to. The function has
                to be of the signature --> `def on_message(client, userdata, message)`
            on_disconnect_func_ref (func_ref): Called when the client disconnects
                from the broker. The function has to be of
                the signature --> `def on_disconnect(client, userdata, rc)`
            credentials (dict): Settings/Configuration for mqtt client.
                If any of the keys are missing, the default values will be considered.
                Example:
                    {
                        "mqttclientid": "<service_name>",
                        "mqttserver": "192.168.1.199",
                        "mqttport": 9999,
                        "maxmqttreconnectdelay": 256,
                        "willsettopic": "dummy/will/topic",
                        "willsetpayload": "dummy_will_payload",
                        "mqttkeepalive": 60,
                        "queuesize": 5,
                        "batchsize": 5,
                        "publishinterval": 60,
                        "certs": {
                            "iotProtocolName": "x-amzn-mqtt-ca",
                            "ca": "<ca file path>",
                            "cert": "<cert file path>",
                            "key": "<key file path>"
                        }
                    }
        """
        credentials = {} if credentials is None else credentials
        self.userdata = userdata
        self.clientId = credentials.get("mqttclientid", None)
        self.log = logging.getLogger("mqtt_lib_{}".format(self.clientId))
        self.log.setLevel(log_level)
        self.server = credentials.get("mqttserver", "127.0.0.1")
        self.port = credentials.get("mqttport", 1883)

        # in seconds
        self.maxMqttReconnectDelay = credentials.get("mqttreconnectdelay", 8)

        self.willSetTopic = credentials.get("willsettopic", "")
        self.willSetPayload = credentials.get("willsetpayload", "")
        self.keepalive = credentials.get("mqttkeepalive", 60)
        self.certs = credentials.get("certs", None)
        self.queueSize = credentials.get("queuesize", 5)
        self.batchSize = credentials.get("batchsize", 5)
        self.publishInterval = credentials.get("publishinterval", 60)
        self.on_connect = on_connect
        self.on_message = on_message
        self.on_disconnect = on_disconnect

        self.batches = {}
        self.queue = Queue(maxsize=self.queueSize)
        self._batch_lock = threading.Lock()
        self.started = False

    def _publish_after_interval(self):
        """
        Publishes from queue and batch after every
        interval of `publishinterval` seconds.
        """
        while self.started:
            self.log.debug("mqtt_publish_interval")

            self._publish_queue()
            self._publish_batches()

            time.sleep(self.publishInterval)

    def _publish_queue(self):
        """
        Publishes all pending items from queue.
        """
        currentQueueSize = self.queue.qsize()

        messages = [self.queue.get() for _ in range(currentQueueSize)]

        for topic, payload in messages:
            self.publish(topic, payload)

    def _publish_batches(self):
        """
        Publishes all pending batches.
        """
        with self._batch_lock:
            for topic, batch in self.batches.items():
                if batch:
                    self.publish(topic, json.dumps(batch))
                    self.batches[topic] = []

    def start(self):
        """
        After instantiation, the user needs to call this method to
        initiate the mqtt connection for communication. This initiates
        the connection and keeps it persistent.
        From this moment, the user can publish or subsribe.
        """
        self.started = True
        threading.Thread(target=self._mqtt_worker).start()
        time.sleep(1)
        threading.Thread(target=self._publish_after_interval).start()

    def stop(self):
        """
        Disconnects mqtt client if exists.
        Stops fixed interval publishing from queue and batch after
        publishing pending items.
        """
        if hasattr(self, "client"):
            self._publish_batches()
            self._publish_queue()
            self.log.info("Disconnecting mqtt client")
            self.client.disconnect()
            self.started = False

    @retry(
        exceptions=(ConnectionRefusedError, OSError),
        delay=1,
        max_delay=8,
        backoff=2,
    )
    def _retry_connection(self):
        """
        This function (_retry_connection) keeps retrying to connect the client
        until the connection has been successfully established with the help of
        retry decorator. This reconnect is only used for the first time
        successful connection. After an initial connection has been established,
        the internal implementation of mqtt protocol itself makes sure that the
        client reconnects.Between each attempt it will wait a number of seconds
        between 1 and mqttreconnectdelay. Initially the reconnection attempt is
        delayed of 1 second. It's doubled between subsequent attempt up to max_delay.

        Exceptions:
            ConnectionRefusedError: If not able to reconnect
            OSError: If not able to reconnect here the with the retry
                    decorator below parameters are used

        Args(for decorator):
            Exception: an exception or a tuple of exceptions to catch. default:Exceptions
            tries: the maximum number of attempts. default: -1 (infinite).
            delay: initial delay between attempts. default: is 0 but we have used 1
            max_delay: the maximum value of delay. default: None and we have used 256.
            backoff: multiplier applied to delay between attempts. default is 1
                (no backoff) but we use 2. So basically it doubles between
                subsequent attempt up to max_delay.
        """
        if self.started:
            self.log.info(f"mqtt_retry server={self.server} port={self.port}")

            self.client.reconnect()

    def _ssl_alpn(self, protocolName, ca, cert, key):
        """
        This method sets up ssl context with alpn in order to connect
        to aws iot. This ssl context is later attached to mqtt client.
        Args:
            protocolName (str): protocol name to set alpn. For aws
                iot broker this is fixed as `x-amzn-mqtt-ca`.
            ca (str): ca file path.
            cert (str): cert file path
            key (str): key file path
        Returns:
            sslContext
        """

        sslContext = ssl.create_default_context()
        sslContext.set_alpn_protocols([protocolName])
        sslContext.load_verify_locations(cafile=ca)
        sslContext.load_cert_chain(certfile=cert, keyfile=key)

        return sslContext

    def _mqtt_worker(self):
        """
        This creates the raw/standard mqtt client and configures it
        according to the parameters passed in the credentials by the
        user.
        After creating the client, it connects the client to the
        broker and keeps that connection persistent forever.
        The client will handle reconnection automatically.
        The callbacks will also be triggered automatically.
        Catches:
            ConnectionRefusedError: If not able to connect for the
                first time.
            OSError: If not able to connect for the first time.
        """

        self.client = mqtt.Client(
            client_id=self.clientId, userdata=self.userdata
        )

        if self.certs:
            iotProtocolName = self.certs["iotProtocolName"]
            ca = self.certs["ca"]
            cert = self.certs["cert"]
            key = self.certs["key"]
            self.client.tls_set_context(
                context=self._ssl_alpn(iotProtocolName, ca, cert, key)
            )

        if self.willSetTopic and self.willSetPayload:
            self.client.will_set(self.willSetTopic, self.willSetPayload)
        self.client.reconnect_delay_set(
            min_delay=1, max_delay=self.maxMqttReconnectDelay
        )
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message

        try:
            self.client.connect(self.server, self.port, self.keepalive)
        except (ConnectionRefusedError, OSError):
            self._retry_connection()

        self.client.loop_start()

    def subscribe_topics(self, topicsToSubscribe):
        """
        Subscribes to topics.
        Args:
            topicsToSubscribe (str/list[str]) : A single topic string
                or a list of multiple topic strings.
        """
        if not hasattr(self, "client"):
            return None

        if isinstance(topicsToSubscribe, list):
            for topic in topicsToSubscribe:
                self.client.subscribe(topic)
        elif isinstance(topicsToSubscribe, str):
            self.client.subscribe(topicsToSubscribe)

    def publish(self, topic, payload):
        """
        Publishes message immediately.

        Args:
            topic (str): The topic string.
            payload (str/int/float): The payload to be published.
        """
        if not hasattr(self, "client"):
            return None

        try:
            mqttMessageInfo = self.client.publish(topic, payload)
            return mqttMessageInfo
        except OSError:
            self.log.warning(
                f"message_publish_error topic={topic}, payload={payload}"
            )
            return None

    def qpublish(self, topic, payload):
        """
        Adds msg into queue. If queue size reaches limit, items are
        published individually.

        Args:
            topic (str): The topic string.
            payload (str/int/float): The payload to be published.
        """
        self.log.debug("qpublish_entry")
        self.queue.put((topic, payload))

        if self.queue.qsize() >= self.queueSize:
            messages = [self.queue.get() for _ in range(self.queueSize)]
            self.log.debug("mqtt_publish_qsize")

            for topic, payload in messages:
                self.publish(topic, payload)

    def batch_publish(self, topic, payload):
        """
        Appends msg into batch corresponding to topic.
        If batch size reaches size limit, then that batch is published.
        """
        with self._batch_lock:
            self.log.debug("batch_publish_entry")

            if topic not in self.batches:
                self.batches[topic] = []

            batch = self.batches[topic]
            batch.append(payload)

            if len(batch) >= self.batchSize:
                self.log.debug("mqtt_publish_batch_size")
                self.publish(topic, json.dumps(batch))
                self.batches[topic] = []

    def publish_high_priority(self, topic, payload, hostname=None, port=None):
        """
        User can simply publish a message without creating a
        persistent client.
        Args:
            topic (str): The topic string.
            payload (str/int/float): The payload to be published.
            hostname (str): The hostname or IP address of the broker. If not
                passed, same server will be used which was passed in
                the constructure.
            port (int): Network port of the server host to connect to. If not
                passed, same server will be used which was passed in
                the constructure.
        """

        hostname = hostname or self.server
        port = port or self.port

        try:
            mqttMessageInfo = publish_single.single(
                topic, payload, hostname=hostname, port=port, keepalive=2
            )
            return mqttMessageInfo
        except OSError:
            self.log.warning(
                f"message_publish_error topic={topic}, payload={payload}"
            )
            return None

    def is_connected(self):
        """
        Returns:
            bool: True means mqtt client connected. False means not connected.
        """

        if hasattr(self, "client"):
            return self.client.is_connected()
        else:
            return False
